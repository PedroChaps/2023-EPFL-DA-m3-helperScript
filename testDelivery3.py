#!/usr/bin/env python3

import argparse
import os, sys, atexit
import textwrap
import time
from datetime import datetime
import threading, subprocess
import itertools
from functools import reduce


import signal
import random
import time
from enum import Enum

from collections import defaultdict, OrderedDict

PROCESSES_BASE_IP = 12000

class color:
   PURPLE = '\033[95m'
   CYAN = '\033[96m'
   DARKCYAN = '\033[36m'
   BLUE = '\033[94m'
   GREEN = '\033[92m'
   YELLOW = '\033[93m'
   RED = '\033[91m'
   BOLD = '\033[1m'
   UNDERLINE = '\033[4m'
   END = '\033[0m'


def debug(*args, **kwargs):
    if False:
        print("[DEBUG] ", *args, **kwargs)


def positive_int(value):
    ivalue = int(value)
    if ivalue <= 0:
        raise argparse.ArgumentTypeError("{} is not positive integer".format(value))
    return ivalue

def do_parsing():
    parser = argparse.ArgumentParser()

    sub_parsers = parser.add_subparsers(dest="command", help="stress a given milestone")
    sub_parsers.required = True
    parser_agreement = sub_parsers.add_parser(
        "agreement", help="stress lattice agreement"
    )

    
    parser_agreement.add_argument(
        "-r",
        "--runscript",
        required=True,
        dest="runscript",
        help="Path to run.sh",
    )

    parser_agreement.add_argument(
        "-l",
        "--logs",
        required=True,
        dest="logsDir",
        help="Directory to store stdout, stderr and outputs generated by the processes",
    )

    parser_agreement.add_argument(
        "-p",
        "--processes",
        required=True,
        type=positive_int,
        dest="processes",
        help="Number of processes that broadcast",
    )

    parser_agreement.add_argument(
        "-n",
        "--proposals",
        required=True,
        type=positive_int,
        dest="proposals",
        help="Maximum number (because it can crash) of proposal that each process can make",
    )

    parser_agreement.add_argument(
        "-v",
        "--proposal-values",
        required=True,
        type=positive_int,
        dest="proposal_max_values",
        help="Maximum size of the proposal set that each process proposes",
    )

    parser_agreement.add_argument(
        "-d",
        "--distinct-values",
        required=True,
        type=positive_int,
        dest="proposals_distinct_values",
        help="The number of distinct values among all proposals",
    )
    
    parser_agreement.add_argument(
        "-s",
        "--seconds",
        required=True,
        type=positive_int,
        dest="duration",
        help="The number of seconds to keep running",
    )
    
    parser_agreement.add_argument(
        "-t",
        "--to_sleep",
        required=True,
        default=False,
        type=lambda x: (str(x).lower() == 'true'),
        dest="to_sleep",
        help="To sleep if an error occurs (so it is easier to debug)",
    )
    
    results = parser.parse_args()
    return results



def checkForErrors(args):
    filepaths = [os.path.join(args.logsDir, f) for f in os.listdir(args.logsDir) if os.path.isfile(os.path.join(args.logsDir, f))]
    filepaths = [f for f in filepaths if f.endswith(".stderr")]
    for file in filepaths:
        if os.path.getsize(file) != 0:
            print(color.YELLOW + f"------------------------------------------------------------" + color.END)
            print(color.YELLOW + f"Warning: There was an error in one of the processes" + color.END)
            print(color.YELLOW + f"------------------------------------------------------------" + color.END)
            print(color.YELLOW + f"{file = }" + color.END)
            if args.to_sleep:
                print(color.RED + f"Sleeping for 999999 seconds so you can debug" + color.END)
                time.sleep(999999)
            exit(1)
    
    

"""
Example of variables:

lines_per_file = [
    ["3 14 81 94", "14 81 94", ...],
    ["3 14 94", "14 81", ...],
    ...
]
"""
def checkValidity_and_count(args, initial_time):
    filepaths = [os.path.join(args.logsDir, f) for f in os.listdir(args.logsDir) if os.path.isfile(os.path.join(args.logsDir, f))]
    debug(f"filepaths: {filepaths}")
    files = [open(f, "r") for f in filepaths if f.endswith(".output")]
    debug(f"files: {files}")
    files_lines = [f.readlines() for f in files]
    debug(f"current_lines: {files_lines}")
    smallest_file_idx = files_lines.index(min(files_lines, key=len))
    
    # For each line in each file, transforms the lines to sets and checks if they are all subsets or superset of eachother
    # The lines are in the format `n1 n2 n3 ... nN`
    for idx in range(len(files_lines[smallest_file_idx])):
        sets = [set(file_lines[idx].split()) for file_lines in files_lines if len(file_lines) > idx]
        debug(f"comparing sets: {sets}")
        for i in range(len(sets)):
            for j in range(len(sets)):
                if i != j and not (sets[i].issubset(sets[j]) or sets[i].issuperset(sets[j])):
                    print(color.RED + f"------------------------------------------------------------" + color.END)
                    print(color.RED + f"Error: The sets are not all subsets or superset of eachother" + color.END)
                    print(color.RED + f"------------------------------------------------------------" + color.END)
                    print(color.RED + f"{files_lines = }" + color.END)
                    print(color.RED + f"{sets = }" + color.END)
                    print(color.RED + f"{sets[i] = }" + color.END)
                    print(color.RED + f"{sets[j] = }" + color.END)
                    print(color.RED + f"The line was {idx = }" + color.END)
                    
                    if args.to_sleep:
                        print(color.RED + f"Sleeping for 999999 seconds so you can debug" + color.END)
                        time.sleep(999999)
                    exit(1)
    
    print()            
    print(f"Success: The sets are all subsets or superset of eachother! :D")
    print()
    
    # Print some statistics
    total_messages = reduce(lambda x,y: x+y, [len(file_lines) for file_lines in files_lines])
    
    print(color.UNDERLINE+ "STATISTICS" + color.END)
    
    print(f"Time elapsed: " + color.UNDERLINE + f"{args.duration}s" + color.END)
    
    print(f"Total number of delivered messages: " + color.UNDERLINE + f"{int(total_messages)} messages" + color.END)
    print(f"Average number of deliveries per minute: " + color.UNDERLINE + f"{int(total_messages / (args.duration / 60))} messages/min" + color.END)
    print()
    print(f"Average number of delivered messages per process: " + color.UNDERLINE + f"{total_messages / args.processes} messages" + color.END)
    print(f"Average number of deliveries per process per minute: " + color.UNDERLINE + f"{int((total_messages / args.processes) / (args.duration / 60))} messages/min" + color.END)
    print()
    print(f"Minimum number of delivered messages per process: " + color.UNDERLINE + f"{min([len(file_lines) for file_lines in files_lines])} messages" + color.END)
    print(f"Maximum number of delivered messages per process: " + color.UNDERLINE + f"{max([len(file_lines) for file_lines in files_lines])} messages" + color.END)


if __name__ == "__main__":
    
    initial_time = time.time()
    print()
    print(color.GREEN + f"---------------------------------------------------------" + color.END)
    print(color.GREEN + f"Starting stress test for delivery3 at {datetime.fromtimestamp(initial_time).strftime('%Y-%m-%d %H:%M:%S')}" + color.END)
    print(color.GREEN + f"---------------------------------------------------------" + color.END)
    
    args = do_parsing()
    
    print(color.DARKCYAN + "Running stress test for delivery3..." + color.END)
    print(color.DARKCYAN + "PLEASE DON'T TOUCH ANYTHING, THIS WILL FINISH AUTOMATICALLY AFTER THE TIME ENDS" + color.END)
    print()
    
    """
    #try:
    process = subprocess.run(
        f"mkdir -p stress_delivery3; /bin/rm -fr stress_delivery3/*; timeout {args.duration}s ./stress.py agreement -r ../template_cpp/run.sh -l stress_delivery3 -p {args.processes} -n {args.proposals} -v {args.proposal_max_values} -d {args.proposals_distinct_values}",
        shell=True,
        #capture_output=True,
        #text=True,
        #check=True
    )
    #except subprocess.CalledProcessError as e:
    #    print(f"Command failed with error: {e}")
    """
    
    subprocess.run(
        f"mkdir -p stress_delivery3", shell=True,
    )
    subprocess.run(
        f"/bin/rm -fr stress_delivery3/*", shell=True,
    )
    process = subprocess.Popen(
        f"./stress.py agreement -r ../template_cpp/run.sh -l stress_delivery3 -p {args.processes} -n {args.proposals} -v {args.proposal_max_values} -d {args.proposals_distinct_values}", 
        shell=True, 
        stdin=subprocess.PIPE,
        #stdout=subprocess.PIPE,
    )
    
    # Sleeps for the duration of the test (minus the time it took to start the test)
    while time.time() - initial_time < args.duration:
        time.sleep(1)
        if round(time.time() - initial_time) > 15:
            print(f"Time elapsed: {round(time.time() - initial_time)}/{args.duration} seconds")
    process.communicate(input=b'\n')
    
    
    print()
    print()
    
    print(color.DARKCYAN + "Stress test for delivery3 completed. Checking if there were any errors" + color.END)
    checkForErrors(args)
    
    print(color.DARKCYAN + "Checking if the results are correct and couting the delivered messages" + color.END)
    checkValidity_and_count(args, initial_time)
    
    final_time = time.time()
    
    print(color.GREEN + f"---------------------------------------------------------------------------" + color.END)
    print(color.GREEN + f"Ending stress test for delivery3 at {datetime.fromtimestamp(final_time).strftime('%Y-%m-%d %H:%M:%S')}. It took {round(final_time - initial_time)} seconds" + color.END)
    print(color.GREEN + f"---------------------------------------------------------------------------" + color.END)